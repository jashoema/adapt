import os
from typing import List, Optional, Any, Dict, Literal
from dataclasses import dataclass
import json


import logfire
from pydantic import BaseModel, Field
from pydantic_ai import Agent, RunContext

from .agent_prompts import SYSTEM_PROMPT
from ..fault_summary.agent import FaultSummary

# Logfire instrumentation is enabled if API key is set
logfire_api_key = os.getenv('LOGFIRE_KEY')
logfire.configure(send_to_logfire='if-token-present')

@dataclass
class ActionPlannerDependencies:
    """
    Dependencies for the action planner agent.
    
    Attributes:
        fault_summary: The FaultSummary object generated by the fault_summary agent
        device_facts: Dictionary containing device facts like hostname, OS version, and model
        settings: Dictionary containing settings like 'debug_mode' and 'simulation_mode'
        custom_instructions: Optional dictionary containing custom troubleshooting steps for this specific fault
        logger: Optional logger instance to use for logging
    """
    fault_summary: FaultSummary
    device_facts: Dict[str, Any]
    settings: Dict[str, bool]
    custom_instructions: Optional[Dict[str, Any]] 
    logger: Optional[Any]
    
@dataclass
class TroubleshootingStep(BaseModel):
    """
    Represents a single diagnostic step in a network troubleshooting plan.

    Attributes:
        description: A clear explanation of this diagnostic step.
        action_type: The type of action being performed: diagnostic, config, exec, or escalation.
        commands: List of CLI commands to execute (may be empty for escalation type).
        output_expectation: What should be expected in the output and how to interpret it.
        requires_approval: Whether this step may impact configurations or service.
    """
    description: str = Field(..., description="What this step checks or accomplishes")
    action_type: Literal["diagnostic", "config", "exec", "escalation"] = Field(
        ..., description="Type of action: diagnostic, config, exec, or escalation"
    )
    commands: List[str] = Field(
        ..., description="List of CLI commands to execute (may be empty for escalation)"
    )
    output_expectation: str = Field(..., description="What success looks like and how the output is used")
    requires_approval: bool = Field(..., description="True if this step could alter configuration or impact services")

# Create the agent with type-safe output and instructions
action_planner = Agent(
    model="openai:gpt-4o",
    system_prompt=SYSTEM_PROMPT,
    output_type=List[TroubleshootingStep],
    deps_type=ActionPlannerDependencies,
    instrument=True,
)

async def run(user_input: str, deps: ActionPlannerDependencies) -> RunContext:
    """
    Run the action planner agent with the given user input.
    
    Args:
        user_input: A description of the network fault
        deps: Dependencies including fault_summary, settings, logger, and latest_user_message
        
    Returns:
        The agent's response object containing the list of TroubleshootingStep items
    """
    # Initialize settings if None in dependencies
    if deps.settings is None:
        deps.settings = {"debug_mode": False, "simulation_mode": True}
    
    # Log debug information if debug mode is enabled
    if deps.settings.get("debug_mode", False) and deps.logger:
        deps.logger.info("Action Planner Agent System Prompt", extra={
            "system_prompt": SYSTEM_PROMPT,
            "user_input": user_input
        })

    # Manually extract fault_summary fields to avoid datetime serialization issues
    fault_summary_dict = {
        "title": deps.fault_summary.title,
        "summary": deps.fault_summary.summary,
        "hostname": deps.fault_summary.hostname,
        "timestamp": deps.fault_summary.timestamp.isoformat() if deps.fault_summary.timestamp else None,
        "severity": deps.fault_summary.severity,
        "metadata": deps.fault_summary.metadata
    }
    
    # Format the input according to the template
    formatted_input = f"fault_summary:\n{json.dumps(fault_summary_dict)}\n\n"
    formatted_input += f"device_facts:\n{json.dumps(deps.device_facts)}\n\n"
    
    if deps.custom_instructions:
        formatted_input += f"custom_instructions:\n{deps.custom_instructions}"
    else:
        formatted_input += "custom_instructions:\n"  # Empty but present

    return await action_planner.run(formatted_input, deps=deps)
